\documentclass[11pt]{article}
\usepackage[]{graphicx}
\usepackage[cymk,table]{xcolor}

% \newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt}

% preamble: change the term and the class here
% knit_child("preamble.Rnw")
% Preamble is stored local to the project
% \usepackage{knitr}
\usepackage[active]{srcltx} % kdvi forward search
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{german}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{fancybox}
\usepackage{animate}
\usepackage{numprint}
\usepackage[official]{eurosym}
\usepackage{siunitx}
\npthousandsep{,}%
%\usepackage[cymk,table]{xcolor} % option clash with tikz package
%\usepackage{color}
%\xdefinecolor{B4}{cmyk}{.25,.05.5,0,0}
%\xdefinecolor{S10}{cmyk}{0 ,0, 0,.1}

% tree-style graphics
\usepackage{tikz}
\usepackage{biblatex}
%
% Layout
% page layout
 \setlength{\parskip}{1ex}
 \setlength{\parindent}{0em}
 \setlength{\textwidth}{17.5cm}
 \addtolength{\oddsidemargin}{-2cm}
 \addtolength{\textheight}{4cm}
 \addtolength{\topmargin}{-2.5cm}
 \renewcommand{\bottomfraction}{\topfraction}
% \addtolength{\footskip}{3cm}
%
% ----------------------------------------------------------------
\vfuzz2pt % Don't report over-full v-boxes if over-edge is small
\hfuzz2pt % Don't report over-full h-boxes if over-edge is small
%

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}


\begin{document}
% common definitions and options
%knit_child("common.Rnw")


%
%---------------------------- INPUT INFORMATION -----------------------------------



% % page layout
%  \setlength{\parskip}{1ex}
%  \setlength{\parindent}{0em}
%  \setlength{\textwidth}{17.5cm}
%  \addtolength{\oddsidemargin}{-2cm}
%  \addtolength{\textheight}{4cm}
%  \addtolength{\topmargin}{-1cm}
% % \addtolength{\footskip}{3cm}

% THEOREMS -------------------------------------------------------
\newtheorem{thm}{Theorem}[section]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
%\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
%\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}
%\numberwithin{equation}{section}
\newcommand{\Fr}{\hbox{Fr}\,}
\newcommand{\proof}{\paragraph*{Beweis:}}
%
\newcommand{\mgp}[1]{%
%{\marginpar{\raggedright \scriptsize\baselineskip3ex#1}}%
}
\newcommand{\Optional}{}
% \newcommand{\sectionSol}[1]{\section*{Solution: #1}}
\newcommand{\sectionSol}[1]{\section*{Solution: #1}}


% MATH -----------------------------------------------------------
\newcommand{\norm}[1]{\left\Vert#1\right\Vert}
\newcommand{\abs}[1]{\left\vert#1\right\vert}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\Real}{\mathbb R}
\newcommand{\eps}{\varepsilon}
\newcommand{\To}{\longrightarrow}
\newcommand{\BX}{\mathbf{B}(X)}
\newcommand{\Acal}{\mathcal{A}}
\newcommand{\ovl}{\overline}
\newcommand{\grad}{\hbox{grad}}
\newcommand{\cov}{\hbox{cov}}
\newcommand{\var}{\hbox{var}}
\newcommand{\stdev}{\hbox{stdev}}
\newcommand{\NPV}{\hbox{NPV}}
\newcommand{\dd}{\hbox{d}}
\newcommand{\erw}{\hbox{E}}
\newcommand{\erwrn}{\erw^{Q}}
\newcommand{\expval}{\mathbb{E}}
\newcommand{\bvec}{\mathbf{b}}
\newcommand{\Rvec}{\mathbf{R}}
\newcommand{\rvec}{\mathbf{r}}
\newcommand{\rmnvec}{\ovl{\mathbf{r}}}
\newcommand{\xvec}{\mathbf{x}}
\newcommand{\yvec}{\mathbf{y}}
\newcommand{\rvece}{\erw[\mathbf{r}]}
\newcommand{\rvecm}{\ovl{\mathbf{r}}}
\newcommand{\Sigvec}{\mathbf{\Sigma}}
\newcommand{\rhovec}{\mathbf{\rho}}
\newcommand{\rmn}{\ovl{r}}
\newcommand{\sigm}{\ovl{\sigma}}
\newcommand{\rbar}{\bar{r}}
\newcommand{\rptf}{r_{\hbox{\scriptsize ptf}}}
\newcommand{\rptfm}{\ovl{r}_{\hbox{\scriptsize ptf}}}
\newcommand{\rrf}{r_{\hbox{\scriptsize rf}}}
\newcommand{\sigptf}{\sigma_{\hbox{\scriptsize ptf}}}
\newcommand{\trans}{{\hbox{\scriptsize\sf T}}}
\newcommand{\ptfweight}{w}
\newcommand{\ptfw}{\ptfweight}
\newcommand{\ptfwvec}{{\mathbf{\ptfw}}}
\newcommand{\onevec}{\mathbf{1}}
\newcommand{\zerovec}{\mathbf{0}}
\newcommand{\nseries}[1]{#1_1,#1_2,\ldots,#1_n}
\newcommand{\series}[1]{1,\ldots,#1}
\newcommand{\enum}[1]{1,2,\ldots,#1}
\newcommand{\idxbox}[1]{\hbox{\scriptsize\rm #1}}
\newcommand{\Barwert}{\hbox{BW}}
\newcommand{\NBW}{\hbox{NBW}}
\newcommand{\Endwert}{\hbox{EW}}
\newcommand{\PresentValue}{\hbox{PV}}
\newcommand{\NetPresentValue}{\hbox{NPV}}
\newcommand{\diff}{\hbox{d}}
\newcommand{\intinf}{\int_{-\infty}^{\infty}}
%\newcommand{\refeq}[1]{(\ref{eq:#1})}
\newcommand{\sigmin}{\sigma_{\hbox{\scriptsize min}}}
\newcommand{\npr}{\numprint}
%
% Input exTitles.Rnw 
% This file contains the labels of the exercises and their titles.
% The file names have the form "<label>.tex" or "<label>.Rnw"
% knit_child(paste(homeDir,rootSammlung,"exTitles.Rnw",sep="/"))
% Moved to "extitles.R", which is sources by "functions.R"
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% #
% # Defition of R functions
% # 
% # All these functions have been moved to "Uebungen/utils/bin/functions.R"
% # Can these definitions be outsourced in an *.R file?
% #
% 
% # exlabel <- ""
% 
% # setexlabel <- function(exLabel) 
% # {
% #   exlabel <- exLabel
% # }
%
% Studiengang WI21a / WI21b / WI20a \hfill Fach: FUM \\ HS 2022 \\ 

\title{Modeling with the FEMS Package}
% \subtitle{Modeling and Simulating the Financial Side of Institutions}
\author{Henriette Elise Breymann}
\date{\today}
\maketitle

\tableofcontents
\thispagestyle{empty}


% \newpage

\section*{Thanks}

\section{Introduction}

\subsection{The digital financial world}

Today's financial system is digital and banks can rightly be considered as
applied IT companys. Our money, our investments and debts are just zillions of
numbers in
huge data bases. From this persective the banking business can formally be
considered of a transformation of these numbers according to specific rules.
And these transformations must be highly automated; otherwise banks could not function.

Unfortunately, the treatment of these numbers is not totally automated across the boards.
Sure, the parts that are vital for banks to subsist do work automatically.
This mainly concerns financial transactions.
But there are other parts that, even though equally important for controlling
and steering the institutions, are
not as vital for the daily business and thus less integrated.
Which generates
large costs for financial institutions and limits the impact of what could be
achieved with optimal automation.
It also limits the possible impact of regulation.

\begin{figure}[h]
  \begin{center}
  \includegraphics[width = 15cm]{./figures/Rabobank_IT.jpg}
  \end{center}
  \caption{Model of the IT landscape of the Rabobank. (from linked-in)}
  \label{fig:Rabo-IT}
\end{figure}

The technical reason is the fragmented IT landscape which itself is a result of
the way this
landscape grew over the years, piece by piece. Each piece --- or subsystem ---
works well for itself but they are not optimally working together. The problem is
the interfaces and, closely related to this, the data standards. And these two very
technical aspects are closely related to the task that they should support, namely
different aspects of banking.
Which means that optimal interfaces and data standards that are up to the
task cannot be constructed without a thorough understanding of banking and finance.
And here is
the rub: IT and banking expertise are rarely found together in a single person.
Bankers care little about the underlying IT, and IT specialists usually are not very
literate in banking. Moreover, different lines of business largely work independent
from one another. Which leads to silo-type structures: integration is well advanced
within a silo but poor across silos. This means that integration across silos
still requires a lot of manual work. Tasks that require this type of integration
can only be carried out in a suboptimal way. As a consequence, regulatory reporting,
which
requires presicely this type of integration, is slow and costly. And the cost-income ratio
of banks is around 60\% or higher.


To help overcoming these shortcomings,
a special infrastructural layer has been developed. However, in order to
motivate the need of this layer and its rationale,
let's first turn to the fundamental building blocks of finance.



\subsection{Financial contracts --- the molecules of the financial system}

The financial system deals with money. Or, more precisely, with the exchange
of money. The most elementary element (the atom) is the exchange of a single
cash flow between two parties. It appropriately describes, e.g.,
the actions of putting money on or withdrawing
it from a bank account. However, for most finance activities this is
a level too low because usually cash flows do not arise in isolation but are
bundled together because they form a whole and serve a purpose.
These bundles are defined by contractual obligations,
so-called financial contracts.
A bond, a loan, a mortgage are prime examples. If you buy a fixed-rate bond, e.g.,
you initially pay the sum to invest. Then you get regularly interest payments and
at the end of its term (maturity) you get your invested money back together with
the last interest payment. All these payments are defined by the terms of the
contract called \emph{bond}.
In general, a financial contract defines a set of cash flow exchanges
between two or more parties.
The time and amount of cash flows may depend
on well-defined external factors. However, the value of these external factors is not
known when the contract is concluded and brings an essential element of change
into the game. Just think of the value of a stock.

To stay in the above-mentioned analogy,
financial contracts are the molecules of the financial system. While in nature
there are only
about 100 (stable) atoms, there are millions of different molecules, from simple ones
as $\text{H}_2\text{O}$ to very complicated, ones such as e.g. alkane chains,
that may consist of thousands of atoms. All these molecules serve different purposes.
Similarly, there are myriads of (often bespoke) financial contracts,
which also serve different, partly very special purposes.
Examples are structured products, exotic derivatives bonds and over-the-counter
contracts.

\begin{figure}[h]
  \begin{center}
  \includegraphics[width = 15cm]{./figures/bowtie.pdf}
  \end{center}
  \caption{Bowtie structure of the financial system with the ACTUS contract types
  at its center. Financial contracts have a central role in the structure
of the financial system.
It contains very diverse inputs (left) and outputs (right) but a highly standardized
and efficient core in the center. }
  \label{fig:Bowtie}
\end{figure}

From the central role of financial contracts it's immediately clear that they
should be the prime focus of standardization. And they should make it possible
to close the gap in the automation of financial analysis.
There have indeed been quite a few
attempts,
each of them focusing on different subsets of financial contracts and with different
purposes in mind. FpML, e.g.,
only focuses on derivatives with the goal of supporting automated transaction.
Ontologies such as Fibo classify financial contracts my means of deep hierachies
with the goal of unequivocal identification of any financial contract. All these
standardization efforts, however, fall short in one way or another. In particualr,
they are not encompassing and don't provide the information needed for financial
analysis. Thus, they are not suitable for supporting automated financial analysis.
To achive this goal, the requirements of financial analytics most be cast. into
the definition of the standard at its very inception.

However, this requires compatible representations of all different types of
contracts. This can best be done at the level of the cash flow stream encoded
by the contract. Indeed, the whole financial analytics can be computed from
these cash flow streams%
% \cite{BBS22}
. There are three large groups of analytics:
liquidity analysis, valuation, and the
computation of income. Each of them can be derived from the cash flow stream
encoded by a financial contract provided that some additional information is
attached to the cash flows%
%\cite{BBS22}
.
Moreover, only linear mathematical
operations are required.
Aggregation across contracts can be done in a similar way by linear
operations%
%\cite{BBS22}
. These requirements of financial analytics must be cast
into the standard at its very inception.

What is needed is thus a standardized digital representation of the cash flow
streams that are encoded by the whole universe of financial contracts. Such a
standard would allow a very efficient automation of financial analysis because
it makes apparent the boy-tie structure of the financial system as depicted
in figure \ref{fig:Bowtie} with a highly standardized, very robust and
computationally efficient core at the center and great variety in the wings.
Such a structure is often found in complex systems showing up in nature and
society. An example outside the world of finance is the metabolism.

This seems a formidable task. However,
from the point of view of pure number processing, the huge variety of
different contracts shrinks enormously. Because the aim of the standard
is not to unequivocally describe what a contract is (= ontology) but how a
works. I.e., which cash flows it generates. To put it philosophically, it's not
a question of being, of unequivocal identification, but of a contract's mode
of action.

% \clearpage

\subsection{The Algorithmic Contract Type Unified Standard (ACTUS)}

The standard that has been constructed with the automation of forward-looking
financial analytics in mind is the so-called ACTUS Algorithmic Contract Type
Unified Standard.
It consists of two part, namely
\begin{itemize}
  \item
  the ACTUS Data Dictionary (ADD) and
  \item
  the ACTUS Cashflow Generation Algorithm (ACGA).
\end{itemize}

\subsection{The logic of ACTUS}
\label{ss:ACTUS-logic}
\begin{figure}[t]
  \begin{center}
  \includegraphics[width = 15cm]{./figures/ACTUS_logic.pdf}
  \end{center}
  \caption{The data-processing logic of an ACTUS contract.}
  \label{fig:ACTUS-logic}
\end{figure}


The first standardizes the data involved in a financial contract and the second
standardizes the digital representation of the cash flow stream encoded by a
financial contract.

Notice that ACTUS cannot be used standalone. It's an enabler.
Such as the standardization of nuts
of bolts in the 19th century was an enabler.
A box of standardized
nuts and bolts without using them for the construction of some device is also
pointless. Still, this standardization gave a boost to industrial development.

The situation in the financial system is somewhat more subtle. The part
that is mandatory for running the daily business is indeed suitably standardized.
These are the transaction systems. However, as has been pointed out above,
there is another layer that concerns
the analytics for both, purposes internal to the institution (upper management)
and external purposes (e.g. regulation). These parts show serious shortcomings.
Unfortunately, usually these shortcomings are papered over and only pop up in
situations of crises. Up to now no
serious effort have been made to fundamentally remedy the situation even though
this would save the banks considerable costs and would made regulation more
transparent and effective, and, as a consequence, the financial system more stable.

% \newpage

Figure \ref{fig:ACTUS-logic} displays the data-processing logic of a ACTUS
contract, which is represented as the green box in the center. You can think
of this box of containing the contract data as nominal, interest rate, start
date, maturity date, etc. These data together with the rules of how to convert
them into future cash flows define the contents of the contract. This information,
however, is not sufficient to derive the future cash flow stream. The reason is
that some contractual terms make reference to outside quantities. For a variable bond,
e.g., the market interest rate is needed for each data, when the interest to be
paid is adapted to the then prevailing market date. An option on a stock requires
the knowledge of the stock price. Different contract require different information
elements from a contract's economic-financial environment. These is data about
future market developments,
which is not available at the time of the evaluation of the future cash flows.
They introduce an important element of risk in the evaluation of a contrast's
future cash flows. Therefore they are henceforce called risk factors.

From the contract data and the risk factor data, a contract's future cash flow
stream can be evaluated by means of the ACTUS Cash-flow Generating Algorithm (ACGA).
This is indicated by the elliptical box under the contract box. The result (light
blue line in the middle) is
the contract's cash flows conditional to the risk factor scenario used in the
evaluation. These are the raw results. From these raw results, all further analysis
can be derived, cf. dark blue box at the bottom.

\subsection{Portfolios of contracts and different risk factor scenarios}

\begin{figure}[h]
  \begin{center}
  \includegraphics[width = 15cm]{./figures/ACTUS_logic2.png}
  \end{center}
  \caption{Data processing for a portfolio of $n$ contracts and $k$ risk factor
  environments.}
  \label{fig:ACTUS-logic2}
\end{figure}

Figure \ref{fig:ACTUS-logic2} illustrates what happens in the case of a portfolio
of $n$ contracts and the presence of $k$ risk factor scenarios.
The contract input data in the ACTUS standard are represented by the blue
rectangles at the top of the input (left) part of the figure. The execution steps
consist of (i) creating stochastic risk factor models and scenarios for stress
testing and Monte Carlo simulations (represented by the red rectangles at the
bottom of the input part); (ii) simulating the contracts’ future cash flows
under suitable scenarios for the risk factors (i.e., the arrow that represents
the ACTUS algorithms that transforms input data into (raw) cash flow results;
(iii) extracting from these cash flows the analytical quantities needed for a
suitable level of aggregation (i.e., arrow “Analytics”).
% <!-- and (iv) optional  -->
% <!-- storage of any of these intermediate results in a scalable persistent datastore  -->
% <!-- to allow reuse, trend analysis and comparisons of specific portfolio and  -->
% <!-- scenario subgroups. This analysis enables regulators authorized to access the  -->
% <!-- contract level positions of an institution to assess its vulnerability towards  -->
% <!-- any relevant stress event by suitable aggregation of the granular data.  -->
% <!-- This can be done for individual institutions or for the financial system overall.  -->
Notice that in step (iii) with the exception of the evaluation of risk measures,
all operations that require extensive aggregation are linear operations (additions
and multiplications) and can very well be executed with databases.

In figure \ref{fig:ACTUS-logic2}, the evaluation of risk factor models,
the cash-flow generation, and the performance of the analytics are separate steps.
This serves two purposes: (i) Separating the huge number of contract information
that is known (since it’s written in the contracts) from the stochastic,
and thus a priori unknown risk factor information, in view of transparent and
parsimonious modeling;
(ii) supporting the efficient computation of a large variety of analytical
quantities by only changing the aggregation part.


% <!-- \begin{figure}[h]  -->
% <!--   \begin{center} -->
% <!--   \includegraphics[width = 15cm]{./figures/Cashflow-Aggregation.pdf} -->
% <!--   \end{center} -->
% <!--   \caption{Aggregation of many ACTUS contracts. Notice that aggregation of  -->
% <!--   cash flow stream only requires linear operations (lower part in green).} -->
% <!--   \label{fig:ContractAggregation} -->
% <!-- \end{figure} -->

\begin{figure}
  \begin{center}
  \includegraphics[width = 15cm]{./figures/System-interactions.png}
  \end{center}
  \caption{Sketch of the financial systems. The interactions are transmitted
  by financial contracts.}
  \label{fig:SystemInteractions}
\end{figure}


\subsection{Toward the analysis of the financial system --- Sketch of an ACTUS ecosystem}

At the end of this introduction we want to briefly point out the possibilities
that open up if all banks have their contracts in the ACTUS format. If the
contract information of all the contracts of all banks is available in a central
database then it would be possible to simulate the future development of all
the banks conditional to the defined risk factor scenarios. I.e., the future
development of the financial system. This is schematically sketched in figure \ref{fig:SystemInteractions}. This would be a powerful tool in the hand of
regulators in situations of crises.

\subsection{Using ACTUS with the FEMS package}

ACTUS provides an infrastructural layer that
makes financial analysis much more powerful. But it cannot be used in
isolation. It's an enabler that needs an environment to make use of it.
In order to give potential users the possibility to become acquainted with ACTUS
and the range of possibilities it provides, we've build the R-package
\verb+FEMS+. So it requires R as platform to run it. The ACTUS algorithms
are running on a separate server and the requests to the server and its answers
are provided through an interface.


The \verb+FEMS+ package gives users the possibility to try out
the modeling of single financial contracts, portfolios of contracts or whole
institution on a demo level. The package uses the ACTUS contract standard and
cash flow generating algorithms that are transparent, efficient and meant to be
usable for even large scale institutions. The aim of this package, however, is
to give users easy access to this technology at an introductory and  demonstration
level. For production level systems the interest users should look for professional
software solutions based on the ACTUS technology.\footnote{%
On example is the product suite of the Ariadne Business Analytics AG.}

% \clearpage

\section{The structure of the FEMS package}

As already stated above, the \verb+FEMS+ package provides functionality for the
modeling, simulation and analysis of the financial side of banks, other financial
institutions and also non-financial corporates. 

The philosophy was to use as
far as possible to typical R-type generic function syntax so that the look and feel is similar
to other R packages. A case in point are the analytical functions \verb+liquidity+,
\verb+value+ and \verb+income+. They can be used on a variety of object such as 
single contracts, portfolios of contracts and whole institutions with the
same syntax. The idea behind this choice is to facilitate the writing of scripts.
Moreover, the logic is viewed from the point of view of the user, not the point of 
view of the programmer. At least, that is what we attempted to do. 

Notice that for the arguments' names we do not use the ACTUS names but simplified 
versions in order to facilitate becoming familiar with the system.
However, the ACTUS names also work, and the more advanced user will encounter them
at one point or the other.

Another point is that for further analysis as well as graphical presentation of
the results the whole power of R can be used.

The package is composed of the following parts:
\begin{itemize}
\item
Installation and setup
\item
Contracts
\item
Risk factors
\item
Events
\item
Aggregation
\item
Analytics
\item
The structure of an institution
\item
Demos with graphical user interface
\end{itemize}


\section{Installation and setup}

<<include = FALSE,echo=FALSE>>=
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
@ 
The \verb+FEMS+ package is available on a public github. In can be installed on
R in the following way:
<<eval=FALSE,results='hide',message=FALSE>>=
# Packages required by FEMS:
packageList <- c("timeDate", "timeSeries", "zoo", "httr", "lubridate", "fmdates",
                 "jsonlite", "readxl", "data.tree", "devtools")
# Installing these packages from CRAN:
install.packages(packageList, repos="https://cloud.r-project.org")
# To install FEMS from public github
devtools::install_github("wbreymann/FEMS")
@

Then, the library is called in the usual way:
<<results='hide',message=FALSE>>=
library(FEMS)
options(warn=-1)
@

For the calculations, a server from [ACTUS Financial Research Foundation](www.actusfrf.com) hosted by ZHAW is used.
Here we define the serverURL required for all calculations.
<<>>=
serverURL <- "https://dadfir3-app.zhaw.ch/"
@
Now we are all set to start creating contracts.

\section{Contracts}

\subsection{Single financial contracts}

\subsubsection{Fixed rate contracts}

Let's start with a simple bond (called \verb+PAM+ or \verb+Principal at Maturity+ 
in ACTUS language). To define a bond, we need to know at least its start date, 
time to maturity, nominal value, and coupon rate (which is the interest rate paid out).
In addition, we have to set its role, namely, whether its long or short. 
The following lines define a long bond with starting date July 31, 2013, time to maturity 
of 3 years, a nominal value of 1000 and a coupon rate of 2\%.
<<>>=
t0 <- "2013-12-31"
bond1 <- bond(start="2013-12-31", maturity = "3 years", nominal = 1000,
               coupon = 0.02, role = "long")
@
Notice that in this minimal version the currency is not specified. It's implicitly
assumed to be CHF but can be set explicitly. 

We can have a look at important contract terms by simply typing the contract name:
<<>>=
bond1
@

With the function \verb+events+ we can generate all events of the contract.
The function takes the following mandatory arguments:
\begin{description}
  \item[objcet]
  The contract or portfolio or institution object
  \item[ad]
  The analysis date as per which all future events are to be derived
  \item[model]
  Optionally, the risk factor enviornment conditional to which events are computed
\end{description}

<<>>=
evs <- events(bond1, t0)
# print(evs, indices=c(-4,-9))
print(evs)
@

The events can be plotted by calling the function \verb+plot+ after the \verb+events+ function.
Notice that \verb+plot+ takes a contract object as argument.
<<eval=FALSE>>=
plot(bond1, t0)
@

<<echo=FALSE,out.extra = 'height=12cm,width=15cm'>>=
plot(bond1, t0)
@

\subsubsection{Variable rate contracts}
\label{sss:floater}
Contracts can also have variable interest rates. Herefore, we need to initialize 
some interest rate risk factors first. This is done with the command \verb+YieldCurve+.
Here we define a 1-month-rate of 1\%, a 20-year-rate of 4\% and interpolate
linearly. 

<<>>=
irShort <- 0.01
irLong <- 0.04
# ir.spread <- 0.01
yc <- YieldCurve(label = "YC.CHF", 
                 ReferenceDate = t0, 
                 Tenors = c("1W", "20Y"), Rates = c(irShort, irLong))
rf <- RFConn(yc)
@

Together with possibly other risk factors the yield curve is bundled into a 
risk factor environment by the command \verb+RFConn+:
<<>>=
rf <- RFConn(yc)
@
For more details, cf. below.

The yield curve can be plotted as well:
<<eval=FALSE>>=
plot(yc)
@
<<echo=FALSE,out.extra = 'height=12cm,width=15cm'>>=
plot(yc)
@

To define a floating bond, we must specify a cycle of rate reset and the label
under which the ACTUS server can find the yield curve. This is respectively done
with the arguments \verb+CycleOfRateReset+ and \verb+MarketObjectCodeOfRateReset+. 
<<>>=
bond2 <- bond(ContractID="002", start = t0, maturity = "5 years", 
                      nominal = 1000, coupon = 0.02, role="long", 
                      CycleOfRateReset="P1YL0", MarketObjectCodeOfRateReset="YC.CHF") 
@
In this example, the value of the argument \verb+CycleOfRateReset="P1YL0"+ means 
that the interest rate is reset to the market rate every year. In order to retrieve
the according information, the corresponding forward rates are computed from the
yiedl curve with the label \verb+"YC.CHF2"+. Notice that this is the label used 
in the yield curve definition above.

To compute the events, we pass the risk ractor environment \verb+rf+ as third argument 
into the \verb+events+ command:
<<echo=c(1,3)>>=
evs <- events(bond2, t0, model=rf)
# print(evs, indices=c(-4,-9))
print(evs)
@

The events can be plotted by calling the function \verb+plot+. Notice that in addition
to the result object from the \verb+events+ command we need to specify the starting
time.
<<eval=FALSE,echo=2>>=
# plot(bond2, t0, rf)
plot(evs, t0)
@
<<echo=FALSE,out.extra = 'height=12cm,width=15cm'>>=
plot(evs, t0)
@

\subsection{Functional contract}


Their is a second group of contracts that are not financial contracts and not
defined as ACTUS Standard Contract Types. We call them functional contracts.
They are defined at the R level and model additional contract events that are needed
for a complete modeling of an institution or firm. Here, we have two types of
contracts in mind: 
\begin{description}
  \item[Investment contracts]
  These contracts model investments into physical assets. They typical will give 
  rise to a large initial cash flow needed for buying the asset and then a series
  depreciation events. Notice that the depreciation events are not associated with 
  cash flows but are required to correctly compute book income.
  \item[Operational cash flow contracts]
  These cash flows arrive from the operational business of the firm. They are not
  related to a financial contract but are needed to model the expenses and revenues
  that arise from the firm's business except financial contracts. Essentially, they
  consist of only a cash flow pattern that is modeled externally and then passed
  to the contract.
\end{description}
The framework of both contracts is similar: The depreciation pattern or the pattern
of operational cash flows is modeled externally as time series and then passed 
to the contract. The contract then computes the contract events from this time series.

The syntax of both contracts is the same:
<<eval=FALSE>>=
Investments(ContractID, Currency, pattern, args)
OperationalCF(ContractID, Currency, pattern=rent.fun, args)
@
Here,
\begin{description}
  \item[ContractID]
  is the unique identifier of the contract
  \item[Currency]
  is the currency of the contract
  \item[pattern]
  is a user-defined function that generates the contract events 
  \item[args]
  is a list of arguments that is passed to the function \verb+pattern+.
\end{description}
\verb+pattern+ returns an object of class \verb+timeSeries+ that describes the
respective contract events. They are of event type \verb+DPR+ in the case of the 
\verb+Investment+ contract and of of event type \verb+OPS+ for operational cash 
flows in the case of an \verb+OperationalCF+ contract.

Here an example of an operational cash flow contract with random payments with 
mean 1000 and standard deviation 100:
<<>>=
tstart <- "2024-01-01"
t0 <- "2023-12-31"
CFSeries <- rnorm(10, 1000, 100)             # Series of cash flows
CFDates <- timeSequence(from = timeDate(tstart), # series of dates
                        by = "1 years", length.out = 10)
#
cf.function <- function(events, times) {   # cash flow generating function
  timeSeries(data=events, charvec=times)
}
cf.function(CFSeries, CFDates)               # test of function
op.cf <- OperationalCF(ContractID="op1", Currency="CHF",  # Define contract
                      pattern=cf.function, 
                      args=list(events=CFSeries, times=CFDates) )
# evs <- events(op.cf, "2020-12-31")                  # Starting 1 day before t0
evs <- events(op.cf, t0)                  # Starting 1 day before t0
print(evs)
@
A series of 10 cash flows of type \verb+OPS+ is generated. The dates of the cash flows
correspond to the dates in the time series \verb+CFDates+. 

The \verb+Investment+ contract is defined in a similar way. Here, we assume that
we have an initial investment of 1000000 at \verb+t0+ and a linear depreciation 
over ten years.
<<>>=
initial <- 1000000
rate <- 0.1
depSeries <- sequence(11, initial, 0, by = -rate*initial)
depDates <- timeSequence(from = timeDate(tstart), by = "1 years", length.out = 11)
dep.function <- function(events, times) {     # depreciation generating function
  timeSeries(data=events, charvec=times)
}
inv <- Investments(ContractID="inv1", Currency="CHF", pattern=dep.function, 
                   args=list(events=depSeries, times=depDates))
evs <- events(inv, t0)
print(evs)
@
Here, at \verb+IED+ a cash outflow of the value of the investment occurs. The
first depreciation event of type \verb+DPR+ occurs at the end of the first year,
followed by nine more depreciation events of the same size. Notice that 
\verb+NominalValue+ accordingly decreases from 1000000 to 0.

\subsection{Portfolios of contracts}

Usually we are not interested in a single contract but in a portfolio of contracts.
We will here show this for a sample portfolio.

<<>>=
Portfolio(list(bond1,bond2))
@

Events for portfolios can be computed in the same way as events for a single 
contract. The resulting event series are just concatenated.
<<>>=
ptf <- Portfolio(list(bond1,bond2))
evs.ptf <- events(ptf, t0, model=rf)
print(evs.ptf)
@


\section{Risk factors}

In subsection~\ref{ss:ACTUS-logic} of the introduction chapter the importance of 
the financial-economic context or risk-factor-environment is pointed out. It's 
represented in red in figure~\ref{fig:ACTUS-logic}. This information is needed
because depending on the contract the future cash flows depend on future values
of the external environment. The interest rate reset of floating bonds is a case
in point. 

Future market rates obviously are not known today. We must predict them by appropriate
models, and these models or the results of such models must be provided to the system.
The most frequent external information needed concerns market interest rates.
This is way we have provided a built-in model that computes forward interest rate
from a yield curve provided to the system. The underlying assumption is that these 
forward rates provide the expectation of future spot interest rates. E.g., according
to this assumption the forward rate $f_{2,3}$ from year 2 to year 3 should be the expectation
of the 1 year spot rate in two years. Even though we empirically know that this 
assumption is wrong, it's often used in practice for modeling purposes.

The risk factor environment is contained in a so-called risk-factor connector.
It is defined by the command \verb+RFConn+, as in the example in section~\ref{sss:floater}.
A yield curve is defined by the \verb+YieldCurve+ command. The resulting object
is added to a risk factor connector. Notice that different risk factors can be contained
in a risk factor connector object. 

% \clearpage

\section{Contract events}
The effect of a financial contract in the future is simulated by means of the 
\verb+events+ function. The result is an \verb+EventSeries+ object. In akddition to
some meta information its main content is the time series of contract events,
the most elementary object of the future action of a financial contract.
Examples are shown above. You see that for a fixed bond, the contract events are
all cash flows but for the floating bond there are additional events related to 
the rate reset. This already indicates that there are different types of events.
In the list, the event type is contained in the \verb+CType+ column. Notice that 
also cash flows can be of different type. The initial cash flow is always or type 
\verb+IED+ (for initial exchange date) and the final cash flow is always of type
\verb+MD+ for maturity date. Also capital payments and interest payments are of 
different type. This is important for the correct computation of the downstream
analysis.

There is a function called \verb+getEventParameters()+ that returns a list of
event types with the associated short names, long names and indications of
how the events are drawn in the plot function.

\begin{table}[t]
\caption{List of event typew}
\begin{tabular}{lllcc}
Abbreviation & description & color & linetype & linewidth
\\\hline
CDD   & Contract Deal Date       & black     & 1 & 2.0\\
IED   & Initial Exchange Date    & red       & 1 & 2.0\\
PRD   & Purchase Date            & red       & 1 & 2.0\\
IP    & Interest Payment         & darkgreen & 1 & 1.5\\
IA    & Interest Accrual         & darkgreen & 2 & 1.5\\
IPCI  & Interest Capitalisation  & darkgreen & 2 & 1.5\\
PR    & Principal Redemption     & red       & 1 & 2.0\\
RR    & Rate Resetting           & green     & 1 & 1.5\\
MD    & Maturity Date            & red       & 1 & 2.0\\
TD    & Termination Date         & red       & 1 & 2.0\\
DV    & Dividend Payment         & blue      & 1 & 1.5\\
MR    & Margining Payment        & darkblue  & 1 & 1.5\\
STD   & Settlement Date          & darkblue  & 1 & 1.5\\
OPPD  & Option Premium Payment   & red.      & 1 & 2.0\\
OPXED & Option Exercise End Date & red       & 1 & 2.0\\
AD0   & Analysis Date            & black     & 1 & 2.0\\
OPS   & Operational Cashflow     & darkgreen & 1 & 2.0\\
DPR   & Depreciation             & darkgreen & 2 & 2.0\\
RES   & Reserves                 & red       & 1 & 2.0\\
ETA   & External Transaction     & red       & 1 & 2.0\\
ITF   & Internal Transfer        & red       & 1 & 2.0\\
NominalValue & NominalValue:     & red       & 2 & 2.0
\end{tabular}
\end{table}

% \clearpage

\section{Aggregation}

The simulation of a large portfolio of contracts would generate myriads of 
cash flow events together with other types of auxiliary events. Without further
processing, the information these raw results contain is not understandable by humans.
To make it understandable, it must be processed further. And this processing mainly
consists of aggregation: Aggregation in time and aggregation across contracts. 
These aggregation operation are weighted sums. And different types of events may
have been to be selected for different types of analyses.

\section{The Structure of an institution}

Up to now we have introduced single contracts and portfolio of contracts. But this
is not enough to model the structure of an institution such of a bank. Let's
consider a small bank with several thousand contracts on its book. These contracts
are grouped together by certain properties. The big divisions are the active side 
and the passive side of the book. On the active side we have subdivisions as 
short term and long term contracts or fixed rate and variable rate. On the passive
side we have debt and equity, and debt is further divided into, .e.g., mortgages,
loans to companies, etc.; and also according to the term and whether fixed or 
variable rate. So we need a possibility to create such structures.

The divisions just sketched can be organized on a hierarchical tree. Therefore,
we model an institution as such a tree. Fortunately, this is supported by R by 
the \verb+data.tree+ package. A tree consists of a hierarchiy of 
that makes available the possibility to create nodes (class \verb+Node+). 
A large variety of attributes can be attached to each node, 
and there are functions for carrying out recursive
computations on the nodes and aggregation across the tree.
In general, a node has one parent and an arbitrary number of children. The uppermost
node (top node or origin of the tree) has no parent. Nodes without children are
called "`leaf nodes"'.

Contracts are contained in the leaf nodes of the model. Technically, this is done
by means of a list of the Ids of the contracts. This is list attached to the 
corresponding leaf node.
Each contract is associated to one and only one leaf node.

% Let's take the example of a simple power plant. To be specific, power is generated
% from gas, so it's a gas power plant. A model of the financial structure of this
% plant may look as follows:
% \begin{verbatim}
%          levelName
% 1 PowerPlant
% 2  ¦--Assets
% 3  ¦   °--LongTerm
% 4  ¦--Liabilities
% 5  ¦   ¦--Debt
% 6  ¦   °--Equity
% 7  °--Operations
% 8      ¦--Revenues
% 9      °--Expenses
% \end{verbatim}
% The origin is labeled PowerPlant. It has three children nodes, namely \verb+Assets+,
% \verb+Liabilities+ and \verb+Operations+. The first two parts are the usual sections
% of a balance sheet. The first section contains financial and technical assets,
% the second all types of debt as well as equity. In addition, we must model the revenues
% and expenses that arise when operating the plant. This is done in the section
% third node labeled \verb+Operations+. All these nodes have children nodes, and the
% children nodes may have other children nodes. But with this structure we can
% already model a simple plant. Here, \verb+LongTerm+, \verb+Debt+, \verb+Equity+,
% \verb+Revenues+, and \verb+Expenses+ are the leave accounts.

Let's consider the example of a very simple bank that on the asset side has just
a current account as short term asset and mortgages as long term assets. 
Its debt just consists of term deposits.

We create the template of the institution model by the function \verb+institution+:
<<>>=
Bank <- institution("Simple Bank")
Bank
@
The result is a quite general template that not only contains an asset and liability
part as required by the balance sheet but also an operations part needed to model
operational costs. The origin (the topmost node) is labeled \verb+Bank+. 
It has three children nodes, namely \verb+Assets+,
\verb+Liabilities+ and \verb+Operations+. The first two parts are the usual sections
of a balance sheet. The first section contains financial and technical assets,
the second all types of debt as well as equity. In addition, we must model the revenues
and expenses that arise when operating e.g. a production factility. This is done in the section
third node labeled \verb+Operations+. All these nodes have children nodes, and the
children nodes may have other children nodes. But with this structure we can
already model simple institutions. 

For banks, operational costs can be neglected in first order
approximation because most cash flows are generated by the financial contracts in 
the balance sheet. For industrial corporate, however, the operations part contains
the main cash flows.

In our simple bank model we also don't need short term assets other than the current 
account. So we want to remove the unnecessary acccounts, which can be done by the
node-related method \verb+<node>$RemoveChild(<child name>)+:
<<results='hide'>>=
Bank$RemoveChild("Operations")      
Bank$Assets$RemoveChild("ShortTerm") 
@
<<echo=FALSE>>=
Bank 
@
In a similar way, the node \verb+FixedAssets+ can be added to the node \verb+Assets+, 
e.g., by the method
<<>>=
Bank$Assets$AddChild("FixedAssets")
Bank
@
We remove it again because in the following we don't need it:
<<results='hide'>>=
Bank$Assets$RemoveChild("FixedAssets") 
@

In order to get a sensible model, this structure needs contents. The contents is
contained in the contracts that are attached to the leaf nodes. 
% In this simple case
% we just have single contracts in the nodes \verb+LongTerm+, \verb+Debt+, \verb+Revenues+,
% and \verb+Expenses+. The \verb+Equity+ node plays a special role because the
% value of equity is defined as the difference of the total value of the firms assets
% minus the total value of its debt.
% 
We want more than just two 
contracts as in the portfolio example above. So we stochastically generate 
10 mortages and 10 term deposits by means of the following script:
<<>>=
ir <- 0.03         # market interest rate
ir.spread <- 0.01  # interest rate spread (for mortgages)
# generate stochastic volume
nom.assets <- floor(rnorm(10,1000,20))
nom.liab <- floor(rnorm(10,1000,20))

mortgages <- list()
termdeposits <- list()
for (i in 1:10) {
mat <- paste0(i, "years")
mortgages[[i]] <- bond(ContractID = paste0("m",i),
  start = "2020-04-01", maturity = mat, nominal = nom.assets[i],
  coupon = ir+ir.spread, role="long") # notice the spread
termdeposits[[i]] <- bond(ContractID = paste0("td",i),
  start = "2020-04-01", maturity = mat, nominal = nom.liab[i],
  coupon = ir, role="short")
}
@
The contracts in these lists can be nicely displayed by converting them into
\verb+Portfolio+ objects:
<<>>=
Portfolio(mortgages)
Portfolio(termdeposits)
@
Notice that the interest the bank receives for mortgages is one percentage point higher
than the interest it must pay for the term deposits. This is the classical business 
model of a bank, but the spread of 1 percentage point is quite low.

Now we add the contracts to the leaf nodes, namely the nodes \verb+Debt+ and
\verb+LongTerm+. This is done by the \verb+addContracts+ 
method:
<<>>=
addContracts(termdeposits, FindNode(Bank, "Debt"))
addContracts(mortgages, FindNode(Bank, "LongTerm"))
@
Notice that the whole path to a node must be entered. In order to make it shorter,
we use the \verb+"FindNode+ method, which returns the whole path to a node:
<<>>=
FindNode(Bank, "LongTerm")
@

Now, we can simulate this bank by means of the \verb+events+ method. We start 
the simulation at \verb+t0 = "2020-01-01"+ (our analysis date) and simulated ten
years into the future. Before doing so we must create
a market environment with an appropriate yield curve. The following script contains
all the required commands:
<<>>=
t0 <- "2020-01-01" 
yc <- YieldCurve(label = "YC.CHF", 
                 ReferenceDate = "2019-12-31", 
                 Tenors = c("1W", "20Y"), Rates = c(0.03, 0.03))
rf <- RFConn(yc)
events(Bank, t0, rf, end_date = "2030-12-31")
@

% \newpage

\section{The time bucket system}

Now we have the raw results in form of all the contract events produced by all the
contracts. These results are stored in the \verb+Bank+ object under the respective
leaf nodes. In order to transform them into meaningful information, we must aggregate
them in different ways. Before doing so we must define a so-called time bucket 
system, which is a system of time intervals that divide the time line. The time
buckets are needed for temporal aggregation.

In order to define a time bucket system we first define a sequence of dates:
<<echo=1>>=
by <- timeSequence(t0, by = "1 year", length.out=11)
by
@
Then, we turn this into a system of successive time intervals, the time buckets:
<<echo=-4>>=
years <- as.character(2020:2029)
tb <- timeBuckets (by, bucketLabs = years, 
                   breakLabs=paste0("1.1.",20:30))
tb
@
Transforming a sequence of dates into a \verb+timeBuckets+ object is mainly a matter
of convenience. The point here is the time intervals have intervals and break points.
When we compute flows, we do it per interval. So we should label intervals.
When we compute state variables, we do it as to a specific date, so that we need
dates as label. The \verb+timeBuckets+ object accommodates for both, as you can
see in the example. Date labels are specified for the break points and period
labels (here years) are specified for the intervals.


\section{Analytics}
Now, we are ready for carrying out the analytics. This can be done 
at the level of the individual contracts, of a portfolio or the level of a whole 
institution. Here, we only show the analytics at the level of the whole institution.
The syntax of portfolio objects or individual contracs is the same.
The aggregation is performed first over time intervals if required; then across 
contracts at the level of each leaf node; and finally across the nodes of the tree. 

There are three standard types of analytics:
\begin{itemize}
  \item
  liquidity
  \item
  income
  \item
  value
\end{itemize}
Liquidity just aggregates all incoming and outgoing cash flows of the defined time
periods. Income aggregates those cash flows that are relevant for income, plus
certain non-cashflow events. Value aggregates the value of all contracts as to a specific date.

The first two are flow quantities which require aggregation over time intervals.
The last is a state quantity. Here the case is more complicated. When evaluating
nominal value, we don't aggregate over time. However, when evalutation market value
(i.e., net present value) we must some over the whole series of discounted cash flows.
Notice that this is a weighted temporal aggregation but not an aggregation over 
specific time intervals defined in the time bucket system.

Now let's illustrate this for our model bank. With all the preparatory steps 
carrying out the analytics is pretty simple and, in the simplest case, just requires 
three lines of commands:
<<echo=1>>=
val <- value(Bank, tb, type = "nominal")
val[,-1]
@
<<>>=
liquidity(Bank, by = tb, type = "marginal", digits = 0)
@
<<>>=
income(Bank, by = tb, type = "marginal", revaluation.gains = FALSE, digits = 0)
@

% \clearpage
% Let's illustrate this for the example of the powerplant. The following report
% shows the yearly liquidity of the powerplant from the years 2018 till 2022.
% \begin{verbatim}
%                       2018   2019   2020   2021   2022
% 1 PowerPlant         42.19  46.68  63.37  80.06  96.74
% 2  ¦--Assets       -100.00   0.00   0.00   0.00   0.00
% 3  ¦   °--LongTerm -100.00   0.00   0.00   0.00   0.00
% 4  ¦--Liabilities   100.00 -12.00 -11.80 -11.60 -11.40
% 5  ¦   ¦--Debt      100.00 -12.00 -11.80 -11.60 -11.40
% 6  ¦   °--Equity      0.00   0.00   0.00   0.00   0.00
% 7  °--Operations     42.19  58.68  75.17  91.66 108.14
% 8      ¦--Revenues  129.67 145.44 161.21 176.98 192.74
% 9      °--Expenses  -87.48 -86.76 -86.04 -85.32 -84.60
% \end{verbatim}
% The
% numbers are million EUR. The \verb+LongTerm+ node contains the technical asset
% that represents the plant. The outflow of 100mio EUR in 2018 is the initial investment.
% Thereafter, there is no further outflow. The numbers in the parent node \verb+Assets+
% are the same because this node has only a single child.
% The money for the investment has been
% borrowed. This is modeled by a loan in the \verb+Debt+ node. The loan has an
% initial value of also 100mio EUR with a linear amortisation over 10 years, i.e.,
% 10mio EUR/year. The interest rate is 2\%. Corespondingly, there is an initial
% inflow in 2018 of 100mio EUR. The outflow in 2019 is 10mio EUR for amortisation
% plus 2mio EUR in interest. The next year, interest has only to be paid on the
% remaining 90mio EUR so that the outgoing cashflow is reduced to 11.8mio EUR. And
% so on. The numbers in the parent node \verb+Liabilities+ are the same even though
% this node has two children. The reason is that the node \verb+Equity+
% does not produce cash flows. The nodes \verb+Revenues+ and \verb+Expenses+ contain
% the operational revenues and expenses, according to their names. The node \verb+Operations+
% is thus the some of the corresponding values of its two children nodes.
% 
% Instead of computing the cashflows per period, we can also aggregate them over
% the years. This results in the following table:
% \begin{verbatim}
%                       2018    2019    2020   2021    2022
% 1 PowerPlant         42.19   88.87  152.24  232.3  329.04
% 2  ¦--Assets       -100.00 -100.00 -100.00 -100.0 -100.00
% 3  ¦   °--LongTerm -100.00 -100.00 -100.00 -100.0 -100.00
% 4  ¦--Liabilities   100.00   88.00   76.20   64.6   53.20
% 5  ¦   ¦--Debt      100.00   88.00   76.20   64.6   53.20
% 6  ¦   °--Equity      0.00    0.00    0.00    0.0    0.00
% 7  °--Operations     42.19  100.87  176.04  267.7  375.84
% 8      ¦--Revenues  129.67  275.11  436.32  613.3  806.04
% 9      °--Expenses  -87.48 -174.24 -260.28 -345.6 -430.20
% \end{verbatim}
% 
% Let's now have a look at the balance sheet, which contains the value (positive on
% the asset side and negative on the liability side) of the firms positions.
% It looks like this:
% \begin{verbatim}
%                    18-01-02 19-01-02 20-01-02 21-01-02 22-01-02 23-01-02
% 1 PowerPlant              0        0        0        0        0        0
% 2  ¦--Assets              0      100       90       80       70       60
% 3  ¦   °--LongTerm        0      100       90       80       70       60
% 4  °--Liabilities         0     -100      -90      -80      -70      -60
% 5      ¦--Debt            0     -100      -90      -80      -70      -60
% 6      °--Equity          0        0        0        0        0        0
% \end{verbatim}
% Here, \verb+Operations+ is missing because no intrinsic value is attributed to operational
% revenues and expenses. The value is generated by the difference of the revenue
% cashflow and the expense cashflow shown in the liquidity report. In a real firm
% this difference is kept in a cash account until further use is made of it. Here
% we have not allowed for such a cash account.
% Thus, we just have initial 100mio EUR for the investment and initial -100 EUR for
% the loan. The investment is written of by 10mio EUR per year which reduces its
% book value accordingly. The model is constructed in such a way that the reduction
% of the plants book value is exactly equal to the amortisation of the loan. Therefore
% both value cancel exactly so that equity is zero.
% 
% It is clear that this is not realistic. From the liquidity report we see that
% for 2018 there is an excess liquidity of 42.19mio EUR, which is the profit
% of the plant. This should be reported in the balance sheet as of end of 2018
% (here Jan 2, 2019). However, this sum is lost. The total sum that gets lost
% over the 5 years of the simulation can be seen by looking at the cumulated
% liquidity. It amounts to nearly 330mio EUR.
% 
% \subsection{The cash collector}
% 
% The aggregated liquidity per period must somehow be carried over to the next
% period in order not to get lost during the simulation of the institution into
% the future. This is done at the level of the entire institution. Since the quantity
% to be carried over is the aggregated liquidity at the level of the institution,
% its computation can directly be used. This could be done, e.g., by adding a
% special leaf node (to be called, e.g., \verb+Cash+). The values of the cumulated
% liquidity at the level of the institution can directly be copied into this account.
% Notice, that no real cash flows are associated with this operation. It is a pur
% booking exercise.
% 
% However, there is an additional component that must be taken into account. This
% is the interest paid to this money. Thus, for every period, interest must be
% added to the value of this account for the corresponding period.
% If we integrate this into the model, we get the following balance sheet:
% \begin{verbatim}
%                     18-01-02 19-01-02 20-01-02 21-01-02 22-01-02 23-01-02
% 1 PowerPlant               0     0.00     0.00     0.00     0.00     0.00
% 2  ¦--Assets               0   143.03   181.51   237.97   312.78   406.31
% 3  ¦   ¦--Cash             0    43.03    91.51   157.97   242.78   346.31
% 4  ¦   °--LongTerm         0   100.00    90.00    80.00    70.00    60.00
% 5  °--Liabilities          0  -143.03  -181.51  -237.97  -312.78  -406.31
% 6      ¦--Debt             0  -100.00   -90.00   -80.00   -70.00   -60.00
% 7      °--Equity           0   -43.03   -91.51  -157.97  -242.78  -346.31
% \end{verbatim}
% Here, we have an additional node \verb+Cash+ that contains the cumulated liquidity
% plus the interest earned with this money. The interest rate to be used should
% be rates typically paid to a current account, i.e., short term rates.
% 

\section{Credit risk}

Credit risk or default risk is the risk that a counterparty cannot fulfill its 
obligations. In this case the credit defaults. This results of the contractual 
cash flow being interrupted. 

Credit default occurs with a certain probability (usually per year) called 
probability of default (short $PD$). If a default event occurs, 
in the worst case the loan or bond holder will not receive
any further cash flow. Typically, however, he or she will still receive a certain 
payment but only a fraction of the outstanding value. This fraction is cause
the recovery rate ($RR$.) The recovery rate is usually expressed as a percentage
of the outstanding value. The share actually lost in an default event is called
Loss Given Default ($LGD$). It's given as $1-RR$.

Let's consider an example. Assume that as of Jan 1st, 2024, 
a bank has a fixed-rate mortgage portfolio of 200 mortgages
with a nominal value of CHF 500'000 each with an interest rate of 5\% 
and a time to maturity of 3 years. 
In the absence of defaults, the evolution of value, liquidity and income over the
next 2 years are as follows:\\[3ex]
\begin{tabular}{|p{4cm}|l|l|l|l|}
Period & 2024-01-01 & 2025-01-01 & 2026-01-01 & 2027-01-01 \\\hline
Value \newline 
[in Mio CHF] & 100 & 100 & 100 & 0 \\\hline
Liquidity \newline
(for the previous year) & 5 & 5 & 5 & 105 \\\hline
Income \newline
(for the previous year) & 5 & 5 & 5 & 5 \\\\
\end{tabular}

Now, let's assume that the probability of default is 1\% per year without recovery.
This means that 1 Mio or two mortgages will default each year, namely at the 
end of 2024 and at the end of 2025. For simplicity we
assume that the default happens at the end of the year right after the interest 
payment. The value and the
forthcoming interest payments of the defaulted mortgages get lost.
Then the time evolution of value, liquidity and income will look as follows:\\[3ex]
\begin{tabular}{|p{4cm}|l|l|l|l|}
Period & 2024-01-01 & 2025-01-01 & 2026-01-01 & 2027-01-01 \\\hline
Value \newline 
[in Mio CHF] & 100 & 99 & 98 & 0 \\\hline
Liquidity \newline
(for the previous year) & 5 & 5 & 4.95 & 101.90 \\\hline
Income \newline
(for the previous year) & 5 & 4 & 3.95 & 3.9 \\\\
\end{tabular}

The value of the portfolio is reduced by 1 Mio CHF each year. At Jan 1st, 2026,
however, the non-defaulted outstanding value is payed back, which is why the value
at this date is 0. In the liquidity statement, the loss of the 1 Mio because of 
the default only shows up in the reduced interest payment. The loss  of the
capital only shows up at maturity, when the outstanding capital is paid back.

Now let's assume that the recovery rate is 50\%. This means that the bank will 
recover have of the capital lost. Again for simplicity we assume that this will
take place immediately. However, this will not change the table above because 
the capital recovered is not longer part of the mortgage portfolio. Instead,
the associated cash flows of 0.5 Mio/year are collected in the current account. 

From the above it is clear that we have two random variables, namely the probability 
of default $PD$ and the recovery rate $RR$. In this simple model, these 
are risk factors related to default. Notice that this is a portfolio view on default
and not a single contract view. Because a single contract is either performing
or in default: it's essential a 0-1 variable.\footnote{%
Notice that in reality the situation is somewhat more complicated.}
In order to evaluate the effect on a portfolio, we need to simulate a sufficiently
large number of contract. In this sense, the portfolio model is a probabilistic 
shortcut.

The single contract default can be modeled in detail. 
Unfortunately, however, there is no possibility to directly communicate 
the risk factors of a portfolio default model to the ACTUS financial contracts. 
Therefore, we need a workaround.

In order to construct this workaround, we need to determine how the disrupted 
event sequence differs from the contractual event sequence in the case of a default 
event. Essentially, this is the difference of the numbers in the two tables above
plus the additional cash flows in the current account because of recovery. This 
looks as follows:
\\[3ex]
\begin{tabular}{|p{4cm}|l|l|l|l|}
Period & 2024-01-01 & 2025-01-01 & 2026-01-01 & 2027-01-01 \\\hline
Value \newline 
[in Mio CHF] & 0 & -1 & -1 & 0 \\\hline
Liquidity \newline
(for the previous year) & 5 & 5 & -0.05 & -3.1 \\\hline
Income \newline
(for the previous year) & 5 & -1 & -1.05 & -1.1 \\\\
\end{tabular}

And on the current account with have the additional liquidity \\[3ex]
\begin{tabular}{|p{4cm}|l|l|l|l|}
Period & 2024-01-01 & 2025-01-01 & 2026-01-01 & 2027-01-01 \\\hline
Liquidity \newline
(for the previous year) & 0 & 0.5 & 0.5 & 0.5 \\\\
\end{tabular}

This means that for eauch year where a default occurs we must create a contract
that accounts for these differences. This can be done by defining a short position
with that nominal of the defaulted value that starts at the date of the default.
All other contract terms remain the same, with the expect of one called 
\verb+"PremiumDiscountAtIED"+. This variable reduces the cash flow at \verb+IED+
accordingly. It takes into account the fact that when generating a short position
for the defaulted value, the bank will receive not the full cash associated with
the contracts nominal value but only the reduced share $RR$, which is zero if 
there is no recovery. For the default at the end of 2024, for the contract we 
define, the following terms must be different:\\[3ex]
\begin{tabular}{l|p{7cm}}
Contract Term & Value \\\hline
\verb+nominal+ & $PD \cdot \text{nominal}$ \\
\verb+role+ & short \\
\verb+PremiumDiscountAtIED+ & $ -PD (1-RR) \cdot \text{nominal}$ \\
time to maturity & to be adjusted such that the contract ends at the same time as the original contract
\end{tabular}
 

\section{Monte Carlo simulation}

\section{Graphical representation of the analysis}

Here is an example of a graphical representation of the result, in this case a
comparison of the time evolution of assets and debt. This example uses the \verb+ggplot2+
library. Notice that it explicitly accesses the rows for assets and debt of the 
\verb+val+ dataframe:
<<>>=
library(ggplot2)
# preparation of data to be plotted
data <- data.frame(
  Date=colnames(val)[-1],
  Type=rep("Assets",10),
  Value=as.numeric(val[2,-1])
)
data <- rbind(data,
              data.frame(
                Date=colnames(val)[-1],
                Type=rep("Debt",10),
                Value=as.numeric(val[6,-1])
              ))
@
And here the plot command:
<<eval=FALSE>>=
ggplot(data, aes(fill=Type, y=Value, x=Date), col=colors) + 
  geom_bar(position="stack", stat="identity")
@
\begin{figure}
<<echo=FALSE,out.extra = 'height=12cm,width=15cm'>>=
ggplot(data, aes(fill=Type, y=Value, x=Date), col=colors) + 
  geom_bar(position="stack", stat="identity")
@
\caption{Time evolution of assets and debt.}
\label{fig:value-barplot}
\end{figure}

The result is displayed in fig.~\ref{fig:value-barplot}.
Similar graphics can be prepared for any type of results.
% \clearpage

\clearpage

\section{Demos with graphical user interface}

to be done

% \newpage



% \begingroup
% \renewcommand{\section}[2]{}%
%\renewcommand{\chapter}[2]{}% for other classes
\begin{thebibliography}{99}
  \bibitem{BBS22}
  W. Breymann, N. Bundi and K. Stockinger,
  \emph{Contract-driven financial reporting: building automated analytics
  pipelines with algorithmic contracts, Big Data and Distributed Ledger
  technology.} In V. Ravi and A. K. Cherukuri [eds.]
  \emph{Handbook of Big Data Analytics. Vol. 2: Applications in ICT, security
  and business analytics.} London, 2022.
\end{thebibliography}
% \endgroup

\end{document}

