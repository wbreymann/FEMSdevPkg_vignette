---
title: "The FEMSdevPkg"
output: 
  rmarkdown::pdf_document:
    toc: true
    toc_depth: 2
    number_sections: true

vignette: >
  %\VignetteIndexEntry{FEMSdevPkg}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
author: "Henriette Elise Breymann and others"
date: "`r Sys.Date()`"
---

\newpage


# Introduction

## The digital financial world

Today's financial system is digital and banks can rightly be considered as 
applied IT companys. Our money, our investments and debts are just zillions of 
numbers in
huge data bases. From this persective the banking business can formally be
considered of a transformation of these numbers according to specific rules.
And these transformations must be highly automated; otherwise banks could not function. 

Unfortunately, the treatment of these numbers is not totally automated across the boards. 
Sure, the parts that are vital for banks to subsist do work automatically. 
This mainly concerns financial transactions.
But there are other parts that, even though equally important for controlling 
and steering the institutions, are
not as vital for the daily business and thus less integrated. 
Which generates
large costs for financial institutions and limits the impact of what could be 
achieved with optimal automation.
It also limits the possible impact of regulation.

```{=latex}
\begin{figure}[h] 
  \begin{center}
  \includegraphics[width = 15cm]{./figures/Rabobank_IT.jpg}
  \end{center}
  \caption{Model of the IT landscape of the Rabobank. (from linked-in)}
  \label{fig:Rabo-IT}
\end{figure}
```

The technical reason is the fragmented IT landscape which itself is a result of 
the way this
landscape grew over the years, piece by piece. Each piece --- or subsystem ---
works well for itself but they are not optimally working together. The problem is
the interfaces and, closely related to this, the data standards. And these two very
technical aspects are closely related to the task that they should support, namely
different aspects of banking. 
Which means that optimal interfaces and data standards that are up to the
task cannot be constructed without a thorough understanding of banking and finance. 
And here is
the rub: IT and banking expertise are rarely found together in a single person.
Bankers care little about the underlying IT, and IT specialists usually are not very 
literate in banking. Moreover, different lines of business largely work independent
from one another. Which leads to silo-type structures: integration is well advanced
within a silo but poor across silos. This means that integration across silos
still requires a lot of manual work. Tasks that require this type of integration 
can only be carried out in a suboptimal way. As a consequence, regulatory reporting, 
which 
requires presicely this type of integration, is slow and costly. And the cost-income ratio
of banks is around 60\% or higher. 


To help overcoming these shortcomings, 
a special infrastructural layer has been developed. However, in order to 
motivate the need of this layer and its rationale, 
let's first turn to the fundamental building blocks of finance.



## Financial contracts --- the molecules of the financial system

The financial system deals with money. Or, more precisely, with the exchange 
of money. The most elementary element (the atom) is the exchange of a single
cash flow between two parties. It appropriately describes, e.g., 
the actions of putting money on or withdrawing
it from a bank account. However, for most finance activities this is
a level too low because usually cash flows do not arise in isolation but are 
bundled together because they form a whole and serve a purpose. 
These bundles are defined by contractual obligations, 
so-called financial contracts.
A bond, a loan, a mortgage are prime examples. If you buy a fixed-rate bond, e.g.,
you initially pay the sum to invest. Then you get regularly interest payments and
at the end of its term (maturity) you get your invested money back together with
the last interest payment. All these payments are defined by the terms of the 
contract called \emph{bond}. 
In general, a financial contract defines a set of cash flow exchanges
between two or more parties. 
The time and amount of cash flows may depend
on well-defined external factors. However, the value of these external factors is not 
known when the contract is concluded and brings an essential element of change
into the game. Just think of the value of a stock.

To stay in the above-mentioned analogy, 
financial contracts are the molecules of the financial system. While in nature 
there are only
about 100 (stable) atoms, there are millions of different molecules, from simple ones
as $\text{H}_2\text{O}$ to very complicated, ones such as e.g. alkane chains, 
that may consist of thousands of atoms. All these molecules serve different purposes.
Similarly, there are myriads of (often bespoke) financial contracts, 
which also serve different, partly very special purposes. 
Examples are structured products, exotic derivatives bonds and over-the-counter 
contracts.

```{=latex}
\begin{figure}[h] 
  \begin{center}
  \includegraphics[width = 15cm]{./figures/bowtie.pdf}
  \end{center}
  \caption{Bowtie structure of the financial system with the ACTUS contract types
  at its center. Financial contracts have a central role in the structure
of the financial system. 
It contains very diverse inputs (left) and outputs (right) but a highly standardized
and efficient core in the center. }
  \label{fig:Bowtie}
\end{figure}
```

From the central role of financial contracts it's immediately clear that they
should be the prime focus of standardization. And they should make it possible
to close the gap in the automation of financial analysis.
There have indeed been quite a few
attempts,
each of them focusing on different subsets of financial contracts and with different
purposes in mind. FpML, e.g., 
only focuses on derivatives with the goal of supporting automated transaction. 
Ontologies such as Fibo classify financial contracts my means of deep hierachies 
with the goal of unequivocal identification of any financial contract. All these
standardization efforts, however, fall short in one way or another. In particualr, 
they are not encompassing and don't provide the information needed for financial
analysis. Thus, they are not suitable for supporting automated financial analysis.
To achive this goal, the requirements of financial analytics most be cast. into
the definition of the standard at its very inception.

However, this requires compatible representations of all different types of 
contracts. This can best be done at the level of the cash flow stream encoded
by the contract. Indeed, the whole financial analytics can be computed from
these cash flow streams \cite{BBS22}. There are three large groups of analytics: 
liquidity analysis, valuation, and the 
computation of income. Each of them can be derived from the cash flow stream 
encoded by a financial contract provided that some additional information is 
attached to the cash flows \cite{BBS22}. 
Moreover, only linear mathematical
operations are required. 
Aggregation across contracts can be done in a similar way by linear 
operations \cite{BBS22}. These requirements of financial analytics must be cast 
into the standard at its very inception.

What is needed is thus a standardized digital representation of the cash flow
streams that are encoded by the whole universe of financial contracts. Such a 
standard would allow a very efficient automation of financial analysis because
it makes apparent the boy-tie structure of the financial system as depicted
in figure \ref{fig:Bowtie} with a highly standardized, very robust and 
computationally efficient core at the center and great variety in the wings.
Such a structure is often found in complex systems showing up in nature and 
society. An example outside the world of finance is the metabolism. 

This seems a formidable task. However, 
from the point of view of pure number processing, the huge variety of 
different contracts shrinks enormously. Because the aim of the standard 
is not to unequivocally describe what a contract is (= ontology) but how a 
works. I.e., which cash flows it generates. To put it philosophically, it's not
a question of being, of unequivocal identification, but of a contract's mode
of action. 

<!-- \clearpage -->

## The Algorithmic Contract Type Unified Standard (ACTUS)

The standard that has been constructed with the automation of forward-looking
financial analytics in mind is the so-called ACTUS Algorithmic Contract Type 
Unified Standard. 
It consists of two part, namely

- the ACTUS Data Dictionary (ADD) and

- the ACTUS Cashflow Generation Algorithm (ACGA).

The first standardizes the data involved in a financial contract and the second
standardizes the digital representation of the cash flow stream encoded by a
financial contract.  

Notice that ACTUS cannot be used standalone. It's an enabler. 
Such as the standardization of nuts 
of bolts in the 19th century was an enabler.
A box of standardized 
nuts and bolts without using them for the construction of some device is also 
pointless. Still, this standardization gave a boost to industrial development. 

The situation in the financial system is somewhat more subtle. The part
that is mandatory for running the daily business is indeed suitably standardized.
These are the transaction systems. However, as has been pointed out above, 
there is another layer that concerns
the analytics for both, purposes internal to the institution (upper management) 
and external purposes (e.g. regulation). These parts show serious shortcomings.
Unfortunately, usually these shortcomings are papered over and only pop up in
situations of crises. Up to now no
serious effort have been made to fundamentally remedy the situation even though 
this would save the banks considerable costs and would made regulation more 
transparent and effective, and, as a consequence, the financial system more stable.

\newpage

## The logic of ACTUS

```{=latex}
\begin{figure}[t] 
  \begin{center}
  \includegraphics[width = 15cm]{./figures/ACTUS_logic.pdf}
  \end{center}
  \caption{The data-processing logic of an ACTUS contract.}
  \label{fig:ACTUS-logic}
\end{figure}
```

Figure \ref{fig:ACTUS-logic} displays the data-processing logic of a ACTUS 
contract, which is represented as the green box in the center. You can think
of this box of containing the contract data as nominal, interest rate, start
date, maturity date, etc. These data together with the rules of how to convert
them into future cash flows define the contents of the contract. This information,
however, is not sufficient to derive the future cash flow stream. The reason is 
that some contractual terms make reference to outside quantities. For a variable bond,
e.g., the market interest rate is needed for each data, when the interest to be
paid is adapted to the then prevailing market date. An option on a stock requires
the knowledge of the stock price. Different contract require different information
elements from a contract's economic-financial environment. These is data about 
future market developments, 
which is not available at the time of the evaluation of the future cash flows. 
They introduce an important element of risk in the evaluation of a contrast's
future cash flows. Therefore they are henceforce called risk factors.

From the contract data and the risk factor data, a contract's future cash flow
stream can be evaluated by means of the ACTUS Cash-flow Generating Algorithm (ACGA).
This is indicated by the elliptical box under the contract box. The result (light
blue line in the middle) is
the contract's cash flows conditional to the risk factor scenario used in the 
evaluation. These are the raw results. From these raw results, all further analysis
can be derived, cf. dark blue box at the bottom.

## Portfolios of contracts and different risk factor scenarios

```{=latex}
\begin{figure}[h] 
  \begin{center}
  \includegraphics[width = 15cm]{./figures/ACTUS_logic2.png}
  \end{center}
  \caption{Data processing for a portfolio of $n$ contracts and $k$ risk factor
  environments.}
  \label{fig:ACTUS-logic2}
\end{figure}
```

Figure \ref{fig:ACTUS-logic2} illustrates what happens in the case of a portfolio
of $n$ contracts and the presence of $k$ risk factor scenarios.
The contract input data in the ACTUS standard are represented by the blue 
rectangles at the top of the input (left) part of the figure. The execution steps 
consist of (i) creating stochastic risk factor models and scenarios for stress 
testing and Monte Carlo simulations (represented by the red rectangles at the 
bottom of the input part); (ii) simulating the contracts’ future cash flows 
under suitable scenarios for the risk factors (i.e., the arrow that represents 
the ACTUS algorithms that transforms input data into (raw) cash flow results; 
(iii) extracting from these cash flows the analytical quantities needed for a 
suitable level of aggregation (i.e., arrow “Analytics”). 
<!-- and (iv) optional  -->
<!-- storage of any of these intermediate results in a scalable persistent datastore  -->
<!-- to allow reuse, trend analysis and comparisons of specific portfolio and  -->
<!-- scenario subgroups. This analysis enables regulators authorized to access the  -->
<!-- contract level positions of an institution to assess its vulnerability towards  -->
<!-- any relevant stress event by suitable aggregation of the granular data.  -->
<!-- This can be done for individual institutions or for the financial system overall.  -->
Notice that in step (iii) with the exception of the evaluation of risk measures,
all operations that require extensive aggregation are linear operations (additions
and multiplications) and can very well be executed with databases. 

In figure \ref{fig:ACTUS-logic2}, the evaluation of risk factor models, 
the cash-flow generation, and the performance of the analytics are separate steps. 
This serves two purposes: (i) Separating the huge number of contract information 
that is known (since it’s written in the contracts) from the stochastic, 
and thus a priori unknown risk factor information, in view of transparent and 
parsimonious modeling; 
(ii) supporting the efficient computation of a large variety of analytical 
quantities by only changing the aggregation part. 


<!-- ```{=latex} -->
<!-- \begin{figure}[h]  -->
<!--   \begin{center} -->
<!--   \includegraphics[width = 15cm]{./figures/Cashflow-Aggregation.pdf} -->
<!--   \end{center} -->
<!--   \caption{Aggregation of many ACTUS contracts. Notice that aggregation of  -->
<!--   cash flow stream only requires linear operations (lower part in green).} -->
<!--   \label{fig:ContractAggregation} -->
<!-- \end{figure} -->
<!-- ``` -->

```{=latex}
\begin{figure}[hb] 
  \begin{center}
  \includegraphics[width = 15cm]{./figures/System-interactions.png}
  \end{center}
  \caption{Sketch of the financial systems. The interactions are transmitted 
  by financial contracts.}
  \label{fig:SystemInteractions}
\end{figure}
```


## Toward the analysis of the financial system --- Sketch of an ACTUS ecosystem

At the end of this introduction we want to briefly point out the possibilities 
that open up if all banks have their contracts in the ACTUS format. If the 
contract information of all the contracts of all banks is available in a central 
database then it would be possible to simulate the future development of all
the banks conditional to the defined risk factor scenarios. I.e., the future 
development of the financial system. This is schematically sketched in figure \ref{fig:SystemInteractions}. This would be a powerful tool in the hand of 
regulators in situations of crises.

## Using ACTUS with FEMSdevPkg

ACTUS provides an infrastructural layer that 
makes financial analysis much more powerful. But it cannot be used in 
isolation. It's an enabler that needs an environment to make use of it. 
In order to give potential users the possibility to become acquainted with ACTUS
and the range of possibilities it provides, we've build the R-package 
\verb+FEMSdevPkg+. So it requires R as platform to run it. The ACTUS algorithms
are running on a separate server and the requests to the server and its answers
are provided through an interface.


The \verb+FEMSdevPkg+ gives users the possibility to try out
the modeling of single financial contracts, portfolios of contracts or whole 
institution on a demo level. The package uses the ACTUS contract standard and 
cash flow generating algorithms that are transparent, efficient and meant to be
usable for even large scale institutions. The aim of this package, however. is
to give users easy access to this technology at an introductory and  demonstration 
level. For production level systems the interest users should look for professional 
software solutions based on the ACTUS technology.\footnote{%
On example is the product suite of the Ariadne Business Analytics AG.}

<!-- \newpage -->

# The structure of the FEMSdevPkg

The package is composed of the following parts:


- Setup

- Contracts

- Risk factors

- Events

- Aggregation 
- Analytics

- The structure of an institution

- Demos with graphical user interface



# Setup
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(pandoc)
options(warn=-1)
```

```{r setup, warning = FALSE, message=FALSE, results='hide'}
library(FEMS)
```
For the calculations, a server from [ACTUS Financial Research Foundation](www.actusfrf.com) hosted by ZHAW is used.
Here we define the serverURL required for all calculations.
```{r}
serverURL <- "https://dadfir3-app.zhaw.ch/"
```
Now we are all set to start creating contracts.

# Contracts

## Single Contracts

### Fixed Rate Contracts

Let's start with a simple PAM (Principal at Maturity) contract.
```{r}
pam1 <- bond(start="2013-12-31", maturity = "5 years", nominal = 1000,
               coupon = 0.02, role = "long")
```

We can have a look at the contract terms.
```{r}
# unlist(pam1$contractTerms)
pam1
```

With the function `generateEventSeries()` we can generate all events of the contract.
The functions takes the following arguments:
- `contract`: The contract object
- `riskFactors``: A list of risk factors (can also be empty)
- `serverURL`: The URL of the server to be used for the calculations

```{r}
evs <- events(pam1, "2013-12-31")
print(evs, indices=c(-4,-9))
```

The events can be plotted afterwards by calling the function `cashflowPlot()`.
```{r}
cashFlows(pam1, "2013-12-31")
```

### Variable Rate Contracts
Contracts can also have variable interest rates. Herefore, we need to initialize some interest rate risk factors first.

<!-- First of all, let's load the sample data from the package. -->
<!-- Suggestion: We could make it available inside the package and load it from there. -->
<!-- ```{r} -->
<!-- mydatadir <- "./mydata" -->
<!-- installSampleData(mydatadir) -->
<!-- ``` -->

<!-- Now we can load the sample data. -->
<!-- ```{r} -->
<!-- falling_fp <- paste0(mydatadir,"/UST5Y_fallingRates.csv") -->
<!-- rising_fp <-  paste0(mydatadir,"/UST5Y_risingRates.csv") -->
<!-- rfx_falling <- sampleReferenceIndex(falling_fp,"UST5Y_fallingRates",  -->
<!--                                     "YC_EA_AAA",100) -->
<!-- rfx_rising <- sampleReferenceIndex(rising_fp,"UST5Y_risingRates", -->
<!--                                    "YC_EA_AAA",100) -->
<!-- ``` -->

<!-- After that we can create a contract with variable rates and generate the events and outputs as before. -->
<!-- ```{r} -->
<!-- pam2 <- bondvr("2020-12-31", maturity = "5 years", nominal = 50000, -->
<!--                coupon = 0.02, paymentFreq = "3 months", role = "long", -->
<!--                rateResetFreq = "1 years", rateResetSpread = 0.01 ) -->
<!-- unlist(pam2$contractTerms) -->
<!-- evs2 <- generateEventSeries(pam2, list(rfx_falling), serverURL) -->
<!-- evs2$events_df -->
<!-- ``` -->
<!-- And also the cashflow plot. -->
<!-- **Need to figure out a way to adjust the size of the plot, not good yet!!** -->
<!-- ```{r, width = 12, height = 8} -->
<!-- cashflowPlot(evs2) -->
<!-- ``` -->

## Portfolios of contracts

# Risk factors

\clearpage

# Events

There is a function called \verb+getEventParameters()+ that returns a list of 
event types with the associated short names long names and indications of
how the events are drawn in the plot function.

```{=latex}
\begin{table}
\caption{List of event typew}
\begin{tabular}{lllcc}
Abbreviation & description & color & linetype & linewidth
\\\hline
CDD   & Contract Deal Date       & black     & 1 & 2.0\\
IED   & Initial Exchange Date    & red       & 1 & 2.0\\
PRD   & Purchase Date            & red       & 1 & 2.0\\
IP    & Interest Payment         & darkgreen & 1 & 1.5\\
IA    & Interest Accrual         & darkgreen & 2 & 1.5\\
IPCI  & Interest Capitalisation  & darkgreen & 2 & 1.5\\
PR    & Principal Redemption     & red       & 1 & 2.0\\
RR    & Rate Resetting           & green     & 1 & 1.5\\
MD    & Maturity Date            & red       & 1 & 2.0\\
TD    & Termination Date         & red       & 1 & 2.0\\
DV    & Dividend Payment         & blue      & 1 & 1.5\\
MR    & Margining Payment        & darkblue  & 1 & 1.5\\
STD   & Settlement Date          & darkblue  & 1 & 1.5\\
OPPD  & Option Premium Payment   & red.      & 1 & 2.0\\
OPXED & Option Exercise End Date & red       & 1 & 2.0\\
AD0   & Analysis Date            & black     & 1 & 2.0\\
OPS   & Operational Cashflow     & darkgreen & 1 & 2.0\\
DPR   & Depreciation             & darkgreen & 2 & 2.0\\
RES   & Reserves                 & red       & 1 & 2.0\\
ETA   & External Transaction     & red       & 1 & 2.0\\
ITF   & Internal Transfer        & red       & 1 & 2.0\\
NominalValue & NominalValue:     & red       & 2 & 2.0
\end{tabular}
\end{table}
```

\clearpage

# Aggregation 

# Analytics

\clearpage

# The Structure of an institution

An institution is modeled as a hierarchical tree. To this respect we use the 
\verb+data.tree+ package that makes available the possibility to create 
models that consist of a hierarchy of nodes (class \verb+Node+). A large variety
of attributes. an be attached to each node and there are functions for carrying out recursive
computations on the node and aggregation across the tree.
In general, a node has one parent and an arbitrary number of children. The uppermost 
node (top node or origin of the tree) has no parent. Nodes without children are
called "leaf nodes". 

Contracts are contained in the leaf nodes of the model. Technically, this is done
by means of a list of the Ids of the contracts assciated with a given leaf node.
Each contract is associated only to one node.

Let's take the example of a simple power plant. To be specific, power is generated
from gas, so it's a gas power plant. A model of the financial structure of this
plant may look as follows:
```{=latex}
\begin{verbatim}
         levelName
1 PowerPlant      
2  ¦--Assets      
3  ¦   °--LongTerm
4  ¦--Liabilities 
5  ¦   ¦--Debt    
6  ¦   °--Equity  
7  °--Operations  
8      ¦--Revenues
9      °--Expenses
\end{verbatim}
```
The origin is labeld PowerPlant. It has three children nodes, namely \verb+Assets+,
\verb+Liabilities+ and \verb+Operations+. The first two parts are the usual sections
of a balance sheet. The first section contains financial and technical assets,
the second all types of debt as well as equity. In addition, we must model the revenues 
and expenses that arise when operating the plant. This is done in the section
third node labeled \verb+Operations+. All these nodes have children nodes, and the 
children nodes may have other children nodes. But with this structure we can 
already model a simple plant. Here, \verb+LongTerm+, \verb+Debt+, \verb+Equity+, 
\verb+Revenues+, and \verb+Expenses+ are the leave accounts. 

In order to get a sensible model, this structure needs contents. The contents is 
contained in the contracts that are attached to the leaf nodes. In this simple case
we just have single contracts in the nodes \verb+LongTerm+, \verb+Debt+, \verb+Revenues+,
and \verb+Expenses+. The \verb+Equity+ node plays a special role because the 
value of equity is defined as the difference of the total value of the firms assets
minus the total value of its debt.

\newpage

# Analytics

Analytics is carried out at the level of the individual contracts and then 
first aggregated across contracts at the level of each leaf node and then 
across the nodes of the tree. There are three standard types of analytics:

- liquidity
- income
- value

Liquidity just aggregates all incoming and outgoing cash flows of the defined time 
periods. Income aggregates those cash flows that are relevant for income, plus
certain non-cashflow events. Value aggregates the value of all contracts.

Let's illustrate this for the example of the powerplant. The following report
shows the yearly liquidity of the powerplant from the years 2018 till 2022. 
```{=latex}
\begin{verbatim}
                      2018   2019   2020   2021   2022
1 PowerPlant         42.19  46.68  63.37  80.06  96.74
2  ¦--Assets       -100.00   0.00   0.00   0.00   0.00
3  ¦   °--LongTerm -100.00   0.00   0.00   0.00   0.00
4  ¦--Liabilities   100.00 -12.00 -11.80 -11.60 -11.40
5  ¦   ¦--Debt      100.00 -12.00 -11.80 -11.60 -11.40
6  ¦   °--Equity      0.00   0.00   0.00   0.00   0.00
7  °--Operations     42.19  58.68  75.17  91.66 108.14
8      ¦--Revenues  129.67 145.44 161.21 176.98 192.74
9      °--Expenses  -87.48 -86.76 -86.04 -85.32 -84.60
\end{verbatim}
```
The
numbers are million EUR. The \verb+LongTerm+ node contains the technical asset
that represents the plant. The outflow of 100mio EUR in 2018 is the initial investment.
Thereafter, there is no further outflow. The numbers in the parent node \verb+Assets+
are the same because this node has only a single child.
The money for the investment has been
borrowed. This is modeled by a loan in the \verb+Debt+ node. The loan has an 
initial value of also 100mio EUR with a linear amortisation over 10 years, i.e.,
10mio EUR/year. The interest rate is 2\%. Corespondingly, there is an initial 
inflow in 2018 of 100mio EUR. The outflow in 2019 is 10mio EUR for amortisation
plus 2mio EUR in interest. The next year, interest has only to be paid on the
remaining 90mio EUR so that the outgoing cashflow is reduced to 11.8mio EUR. And 
so on. The numbers in the parent node \verb+Liabilities+ are the same even though
this node has two children. The reason is that the node \verb+Equity+ 
does not produce cash flows. The nodes \verb+Revenues+ and \verb+Expenses+ contain
the operational revenues and expenses, according to their names. The node \verb+Operations+
is thus the some of the corresponding values of its two children nodes.

Instead of computing the cashflows per period, we can also aggregate them over
the years. This results in the following table:
```{=latex}
\begin{verbatim}
                      2018    2019    2020   2021    2022
1 PowerPlant         42.19   88.87  152.24  232.3  329.04
2  ¦--Assets       -100.00 -100.00 -100.00 -100.0 -100.00
3  ¦   °--LongTerm -100.00 -100.00 -100.00 -100.0 -100.00
4  ¦--Liabilities   100.00   88.00   76.20   64.6   53.20
5  ¦   ¦--Debt      100.00   88.00   76.20   64.6   53.20
6  ¦   °--Equity      0.00    0.00    0.00    0.0    0.00
7  °--Operations     42.19  100.87  176.04  267.7  375.84
8      ¦--Revenues  129.67  275.11  436.32  613.3  806.04
9      °--Expenses  -87.48 -174.24 -260.28 -345.6 -430.20
\end{verbatim}
```

Let's now have a look at the balance sheet, which contains the value (positive on 
the asset side and negative on the liability side) of the firms positions.
It looks like this:
\clearpage
```{=latex}
\begin{verbatim}
                   18-01-02 19-01-02 20-01-02 21-01-02 22-01-02 23-01-02
1 PowerPlant              0        0        0        0        0        0
2  ¦--Assets              0      100       90       80       70       60
3  ¦   °--LongTerm        0      100       90       80       70       60
4  °--Liabilities         0     -100      -90      -80      -70      -60
5      ¦--Debt            0     -100      -90      -80      -70      -60
6      °--Equity          0        0        0        0        0        0
\end{verbatim}
```
Here, \verb+Operations+ is missing because no intrinsic value is attributed to operational
revenues and expenses. The value is generated by the difference of the revenue
cashflow and the expense cashflow shown in the liquidity report. In a real firm
this difference is kept in a cash account until further use is made of it. Here
we have not allowed for such a cash account.
Thus, we just have initial 100mio EUR for the investment and initial -100 EUR for 
the loan. The investment is written of by 10mio EUR per year which reduces its 
book value accordingly. The model is constructed in such a way that the reduction
of the plants book value is exactly equal to the amortisation of the loan. Therefore
both value cancel exactly so that equity is zero.

It is clear that this is not realistic. From the liquidity report we see that 
for 2018 there is an excess liquidity of 42.19mio EUR, which is the profit
of the plant. This should be reported in the balance sheet as of end of 2018 
(here Jan 2, 2019). However, this sum is lost. The total sum that gets lost 
over the 5 years of the simulation can be seen by looking at the cumulated
liquidity. It amounts to nearly 330mio EUR.

## The cash collector

The aggregated liquidity per period must somehow be carried over to the next 
period in order not to get lost during the simulation of the institution into 
the future. This is done at the level of the entire institution. Since the quantity
to be carried over is the aggregated liquidity at the level of the institution,
its computation can directly be used. This could be done, e.g., by adding a 
special leaf node (to be called, e.g., \verb+Cash+). The values of the cumulated
liquidity at the level of the institution can directly be copied into this account.
Notice, that no real cash flows are associated with this operation. It is a pur
booking exercise.

However, there is an additional component that must be taken into account. This
is the interest paid to this money. Thus, for every period, interest must be 
added to the value of this account for the corresponding period. 
If we integrate this into the model, we get the following balance sheet:
```{=latex}
\begin{verbatim}
                    18-01-02 19-01-02 20-01-02 21-01-02 22-01-02 23-01-02
1 PowerPlant               0     0.00     0.00     0.00     0.00     0.00
2  ¦--Assets               0   143.03   181.51   237.97   312.78   406.31
3  ¦   ¦--Cash             0    43.03    91.51   157.97   242.78   346.31
4  ¦   °--LongTerm         0   100.00    90.00    80.00    70.00    60.00
5  °--Liabilities          0  -143.03  -181.51  -237.97  -312.78  -406.31
6      ¦--Debt             0  -100.00   -90.00   -80.00   -70.00   -60.00
7      °--Equity           0   -43.03   -91.51  -157.97  -242.78  -346.31
\end{verbatim}
```
Here, we have an additional node \verb+Cash+ that contains the cumulated liquidity
plus the interest earned with this money. The interest rate to be used should
be rates typically paid to a current account, i.e., short term rates.


\clearpage

# Demos with graphical user interface

\newpage

# References 

```{=latex}
\begingroup
\renewcommand{\section}[2]{}%
%\renewcommand{\chapter}[2]{}% for other classes
\begin{thebibliography}{99} 
  \bibitem{BBS22}
  W. Breymann, N. Bundi and K. Stockinger, 
  \emph{Contract-driven financial reporting: building automated analytics 
  pipelines with algorithmic contracts, Big Data and Distributed Ledger
  technology.} In V. Ravi and A. K. Cherukuri [eds.] 
  \emph{Handbook of Big Data Analytics. Vol. 2: Applications in ICT, security 
  and business analytics.} London, 2022.
\end{thebibliography}
\endgroup
```



